<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Theory & Hamming Code Interactive Demonstrator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .project-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            color: white;
        }

        .section {
            background: white;
            padding: 30px;
            margin: 20px 0;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        input, button, select {
            padding: 12px 15px;
            font-size: 1em;
            border: 2px solid #ddd;
            border-radius: 6px;
            transition: all 0.3s;
        }

        input {
            flex: 1;
            min-width: 200px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            min-width: 120px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        #graphCanvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            display: block;
            background: white;
            margin: 20px 0;
            width: 100%;
            max-width: 600px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #f0f0f0;
            font-weight: bold;
            color: #333;
        }

        tr:hover {
            background: #f9f9f9;
        }

        .result-box {
            background: #f0f7ff;
            padding: 20px;
            border-left: 4px solid #667eea;
            border-radius: 6px;
            margin: 15px 0;
        }

        .result-label {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .result-value {
            font-family: 'Courier New', monospace;
            background: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            word-break: break-all;
        }

        .error {
            background: #ffe6e6;
            border-left-color: #e74c3c;
            color: #c0392b;
        }

        .success {
            background: #e6ffe6;
            border-left-color: #27ae60;
            color: #229954;
        }

        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #2196F3;
        }

        .matrix-display {
            display: grid;
            gap: 10px;
            margin: 15px 0;
        }

        .matrix-row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .matrix-cell {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ddd;
            background: #f9f9f9;
            font-weight: bold;
        }

        .degree-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .degree-item {
            background: #f0f7ff;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }

        .node-name {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .node-degree {
            color: #666;
            margin-top: 5px;
        }

        .hub-badge {
            background: #ffd700;
            color: #333;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-top: 5px;
            display: inline-block;
        }

        footer {
            text-align: center;
            color: white;
            margin-top: 40px;
            padding: 20px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .team-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            color: white;
            margin-top: 15px;
        }

        .team-info p {
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .section {
                padding: 20px;
            }

            .input-group {
                flex-direction: column;
            }

            input {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üî¢ Interactive Graph Theory & Hamming Code Demonstrator</h1>
            <p class="subtitle">Visualize Network Topology & Error Correction in Real-Time</p>
            <div class="project-info">
                <p><strong>Subject:</strong> Matrices & Differential Calculus</p>
                <p><strong>Institution:</strong> Shah and Anchor Kutchhi Engineering College</p>
                <p><strong>Academic Year:</strong> 2025-2026</p>
            </div>
        </header>

        <!-- SECTION 1: GRAPH VISUALIZATION -->
        <div class="section">
            <h2>üìä Part 1: Graph Network Visualization</h2>
            
            <div class="info-box">
                <strong>üìù Instructions:</strong> Enter nodes (comma-separated) and edges (format: A-B,B-C,C-A). 
                The application will visualize your network and calculate metrics.
            </div>

            <div class="input-group">
                <input type="text" id="nodesInput" placeholder="Enter nodes (e.g., A,B,C,D)" value="A,B,C,D">
            </div>

            <div class="input-group">
                <input type="text" id="edgesInput" placeholder="Enter edges (e.g., A-B,B-C,C-A,A-D)" value="A-B,B-C,C-A,A-D">
            </div>

            <button onclick="visualizeGraph()">Visualize Network</button>
            <button onclick="loadExample1()">Load Example 1</button>
            <button onclick="loadExample2()">Load Example 2</button>

            <canvas id="graphCanvas" width="600" height="400"></canvas>

            <div id="graphError" class="result-box" style="display:none;"></div>
        </div>

        <!-- SECTION 2: GRAPH METRICS -->
        <div class="section">
            <h2>üìà Part 2: Network Metrics Analysis</h2>

            <div id="metricsContainer" style="display:none;">
                <h3 style="color:#667eea; margin-bottom:15px;">Adjacency Matrix</h3>
                <div class="matrix-display" id="matrixDisplay"></div>

                <h3 style="color:#667eea; margin-top:25px; margin-bottom:15px;">Node Degrees</h3>
                <div class="degree-list" id="degreeList"></div>

                <h3 style="color:#667eea; margin-top:25px; margin-bottom:15px;">Network Statistics</h3>
                <table>
                    <tr>
                        <th>Metric</th>
                        <th>Value</th>
                    </tr>
                    <tr>
                        <td>Hub Node (Highest Degree)</td>
                        <td id="hubNode">-</td>
                    </tr>
                    <tr>
                        <td>Hub Node Degree</td>
                        <td id="hubDegree">-</td>
                    </tr>
                    <tr>
                        <td>Total Nodes</td>
                        <td id="totalNodes">-</td>
                    </tr>
                    <tr>
                        <td>Total Edges</td>
                        <td id="totalEdges">-</td>
                    </tr>
                    <tr>
                        <td>Network Density (%)</td>
                        <td id="density">-</td>
                    </tr>
                    <tr>
                        <td>Network Sparsity (%)</td>
                        <td id="sparsity">-</td>
                    </tr>
                    <tr>
                        <td>Average Degree</td>
                        <td id="avgDegree">-</td>
                    </tr>
                </table>
            </div>

            <div id="noMetrics" class="result-box error" style="display:none;">
                ‚ùå Please create a graph first to see metrics
            </div>
        </div>

        <!-- SECTION 3: HAMMING CODE -->
        <div class="section">
            <h2>üîê Part 3: Hamming(7,4) Error Correction Code</h2>

            <div class="info-box">
                <strong>üìù How it works:</strong> The Hamming(7,4) code converts a 4-bit message into a 7-bit codeword 
                that can detect and correct single-bit errors. This is used in real applications like RAM, QR codes, and satellite communication.
            </div>

            <h3 style="color:#667eea; margin: 20px 0 15px 0; font-size: 1.1em;">Encode 4-Bit Message to 7-Bit Codeword</h3>
            <div class="input-group">
                <input type="text" id="messageInput" placeholder="Enter 4-bit message (e.g., 1011)" maxlength="4" value="1011">
                <button onclick="encodeHamming()">Encode</button>
                <button onclick="randomMessage()">Random Message</button>
            </div>

            <div id="encodeResult" class="result-box" style="display:none;">
                <div class="result-label">Original Message (4 bits):</div>
                <div class="result-value" id="origMessage"></div>

                <div class="result-label" style="margin-top:15px;">Generated Codeword (7 bits):</div>
                <div class="result-value" id="generatedCodeword"></div>

                <div class="result-label" style="margin-top:15px;">Parity Bits (P1, P2, P4):</div>
                <div class="result-value" id="parityBits"></div>
            </div>

            <h3 style="color:#667eea; margin: 30px 0 15px 0; font-size: 1.1em;">Decode & Correct Errors</h3>
            <div class="input-group">
                <input type="text" id="receivedCodeword" placeholder="Enter 7-bit received codeword" maxlength="7" value="1010100">
                <button onclick="decodeHamming()">Decode & Correct</button>
            </div>

            <div id="decodeResult" class="result-box" style="display:none;">
                <div class="result-label">Received Codeword (7 bits):</div>
                <div class="result-value" id="receivedValue"></div>

                <div class="result-label" style="margin-top:15px;">Syndrome (Error Position):</div>
                <div class="result-value" id="syndromeValue"></div>

                <div id="errorStatus" style="margin-top:15px;"></div>

                <div class="result-label" style="margin-top:15px;">Corrected Codeword (7 bits):</div>
                <div class="result-value" id="correctedCodeword"></div>

                <div class="result-label" style="margin-top:15px;">Decoded Message (4 bits):</div>
                <div class="result-value" id="decodedMessage"></div>

                <div class="result-label" style="margin-top:15px;">Data Bits Recovered:</div>
                <div class="result-value" id="dataBits"></div>
            </div>

            <div id="hammingError" class="result-box error" style="display:none;"></div>
        </div>

        <!-- SECTION 4: REAL-WORLD APPLICATIONS -->
        <div class="section">
            <h2>üåç Real-World Applications</h2>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                <div class="info-box" style="border-left-color: #27ae60;">
                    <strong>üì° Satellite Communication</strong>
                    <p style="margin-top:10px;">Hamming codes protect data transmitted from satellites, where retransmission is costly or impossible.</p>
                </div>

                <div class="info-box" style="border-left-color: #e74c3c;">
                    <strong>üíæ Computer RAM (ECC Memory)</strong>
                    <p style="margin-top:10px;">Error-Correcting Code memory uses Hamming codes to detect and fix single-bit errors that occur due to radiation.</p>
                </div>

                <div class="info-box" style="border-left-color: #f39c12;">
                    <strong>üì± QR Codes</strong>
                    <p style="margin-top:10px;">QR codes use Reed-Solomon codes (advanced Hamming variant) to maintain readability even when partially damaged.</p>
                </div>

                <div class="info-box" style="border-left-color: #3498db;">
                    <strong>üåê Network Infrastructure</strong>
                    <p style="margin-top:10px;">Graph theory algorithms optimize network routing and identify critical nodes for infrastructure redundancy.</p>
                </div>

                <div class="info-box" style="border-left-color: #9b59b6;">
                    <strong>üìä Social Networks</strong>
                    <p style="margin-top:10px;">Graph algorithms analyze connectivity patterns, identify communities, and recommend connections.</p>
                </div>

                <div class="info-box" style="border-left-color: #1abc9c;">
                    <strong>üéÆ Video Game AI</strong>
                    <p style="margin-top:10px;">Graph theory powers pathfinding algorithms (like A*) that help NPCs navigate game worlds efficiently.</p>
                </div>
            </div>
        </div>

        <footer>
            <p><strong>üéì Matrices & Differential Calculus - Self Learning Micro Project Report</strong></p>
            <p>Stage 3: Interactive Web Application Demonstrator</p>
            <div class="team-info">
                <p><strong>Team Members:</strong></p>
                <p>‚Ä¢ Veer Doshi (Roll No. 10) - Full-Stack Development</p>
                <p>‚Ä¢ Gagan Gowda (Roll No. 12) - UI/UX Design</p>
                <p>‚Ä¢ Paresh Kulriya (Roll No. 22) - Testing & Analysis</p>
                <p>‚Ä¢ Druman Nagda (Roll No. 31) - Architecture & Deployment</p>
            </div>
            <p style="margin-top:20px; opacity: 0.8;">¬© 2025 Shah and Anchor Kutchhi Engineering College</p>
        </footer>
    </div>

    <script>
        // ============================================
        // GRAPH VISUALIZATION FUNCTIONS
        // ============================================

        function visualizeGraph() {
            const nodesInput = document.getElementById('nodesInput').value.trim();
            const edgesInput = document.getElementById('edgesInput').value.trim();
            const errorDiv = document.getElementById('graphError');
            const metricsContainer = document.getElementById('metricsContainer');
            const noMetrics = document.getElementById('noMetrics');

            errorDiv.style.display = 'none';
            metricsContainer.style.display = 'none';
            noMetrics.style.display = 'none';

            if (!nodesInput || !edgesInput) {
                showError(errorDiv, '‚ùå Please enter both nodes and edges');
                return;
            }

            try {
                const nodes = nodesInput.split(',').map(n => n.trim().toUpperCase()).filter(n => n);
                const edgesRaw = edgesInput.split(',').map(e => e.trim().toUpperCase());
                
                if (nodes.length === 0) {
                    throw new Error('No valid nodes provided');
                }

                const edges = [];
                for (let edge of edgesRaw) {
                    const [src, dest] = edge.split('-');
                    if (!src || !dest) continue;
                    if (!nodes.includes(src) || !nodes.includes(dest)) {
                        throw new Error(`Edge ${edge} references invalid nodes`);
                    }
                    edges.push([src, dest]);
                }

                // Create adjacency matrix
                const adjMatrix = createAdjacencyMatrix(nodes, edges);
                
                // Draw graph
                drawGraphVisualization(nodes, edges);
                
                // Calculate and display metrics
                displayMetrics(nodes, edges, adjMatrix);

                metricsContainer.style.display = 'block';

            } catch (error) {
                showError(errorDiv, `‚ùå Error: ${error.message}`);
                metricsContainer.style.display = 'none';
            }
        }

        function createAdjacencyMatrix(nodes, edges) {
            const n = nodes.length;
            const matrix = Array(n).fill(0).map(() => Array(n).fill(0));

            for (let [src, dest] of edges) {
                const i = nodes.indexOf(src);
                const j = nodes.indexOf(dest);
                matrix[i][j] = 1;
                matrix[j][i] = 1; // Undirected graph
            }

            return matrix;
        }

        function drawGraphVisualization(nodes, edges) {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 120;

            // Calculate node positions (circular layout)
            const positions = {};
            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * 2 * Math.PI;
                positions[node] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            });

            // Draw edges
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            for (let [src, dest] of edges) {
                const start = positions[src];
                const end = positions[dest];
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();

                // Draw arrow
                drawArrow(ctx, start, end);
            }

            // Draw nodes
            nodes.forEach(node => {
                const pos = positions[node];
                ctx.fillStyle = '#667eea';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 25, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node, pos.x, pos.y);
            });
        }

        function drawArrow(ctx, from, to) {
            const headlen = 15;
            const angle = Math.atan2(to.y - from.y, to.x - from.x);
            
            ctx.fillStyle = '#667eea';
            ctx.beginPath();
            ctx.moveTo(to.x - headlen * Math.cos(angle - Math.PI / 6), to.y - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(to.x, to.y);
            ctx.lineTo(to.x - headlen * Math.cos(angle + Math.PI / 6), to.y - headlen * Math.sin(angle + Math.PI / 6));
            ctx.fill();
        }

        function displayMetrics(nodes, edges, adjMatrix) {
            // Display adjacency matrix
            let matrixHTML = '';
            matrixHTML += '<div class="matrix-row"><div class="matrix-cell"></div>';
            nodes.forEach(node => {
                matrixHTML += `<div class="matrix-cell"><strong>${node}</strong></div>`;
            });
            matrixHTML += '</div>';

            adjMatrix.forEach((row, i) => {
                matrixHTML += '<div class="matrix-row">';
                matrixHTML += `<div class="matrix-cell"><strong>${nodes[i]}</strong></div>`;
                row.forEach(val => {
                    matrixHTML += `<div class="matrix-cell">${val}</div>`;
                });
                matrixHTML += '</div>';
            });

            document.getElementById('matrixDisplay').innerHTML = matrixHTML;

            // Calculate degrees
            const degrees = {};
            nodes.forEach((node, i) => {
                degrees[node] = adjMatrix[i].reduce((a, b) => a + b, 0);
            });

            // Display degrees
            let degreeHTML = '';
            Object.entries(degrees).forEach(([node, degree]) => {
                degreeHTML += `
                    <div class="degree-item">
                        <div class="node-name">${node}</div>
                        <div class="node-degree">Degree: ${degree}</div>
                    </div>
                `;
            });
            document.getElementById('degreeList').innerHTML = degreeHTML;

            // Calculate statistics
            const hubNode = Object.keys(degrees).reduce((a, b) => degrees[a] > degrees[b] ? a : b);
            const hubDegreeValue = degrees[hubNode];
            const totalEdges = edges.length;
            const maxPossibleEdges = (nodes.length * (nodes.length - 1)) / 2;
            const densityValue = ((totalEdges / maxPossibleEdges) * 100).toFixed(2);
            const sparsityValue = (100 - densityValue).toFixed(2);
            const avgDegreeValue = (Object.values(degrees).reduce((a, b) => a + b, 0) / nodes.length).toFixed(2);

            document.getElementById('hubNode').textContent = hubNode;
            document.getElementById('hubDegree').textContent = hubDegreeValue;
            document.getElementById('totalNodes').textContent = nodes.length;
            document.getElementById('totalEdges').textContent = totalEdges;
            document.getElementById('density').textContent = densityValue;
            document.getElementById('sparsity').textContent = sparsityValue;
            document.getElementById('avgDegree').textContent = avgDegreeValue;
        }

        function loadExample1() {
            document.getElementById('nodesInput').value = 'A,B,C,D,E';
            document.getElementById('edgesInput').value = 'A-B,A-C,B-D,C-E,D-E';
            visualizeGraph();
        }

        function loadExample2() {
            document.getElementById('nodesInput').value = 'Router_A,Router_B,Router_C,Router_D';
            document.getElementById('edgesInput').value = 'Router_A-Router_B,Router_B-Router_C,Router_C-Router_D,Router_D-Router_A';
            visualizeGraph();
        }

        // ============================================
        // HAMMING CODE FUNCTIONS
        // ============================================

        function encodeHamming() {
            const messageInput = document.getElementById('messageInput').value.trim();
            const encodeResult = document.getElementById('encodeResult');
            const hammingError = document.getElementById('hammingError');

            hammingError.style.display = 'none';
            encodeResult.style.display = 'none';

            if (messageInput.length !== 4) {
                showError(hammingError, '‚ùå Message must be exactly 4 bits (0s and 1s)');
                return;
            }

            if (!/^[01]{4}$/.test(messageInput)) {
                showError(hammingError, '‚ùå Message must only contain 0s and 1s');
                return;
            }

            const messageBits = messageInput.split('').map(Number);
            
            // Position mapping in Hamming(7,4):
            // Position: 1  2  3  4  5  6  7
            // Bit type: P1 P2 D1 P4 D2 D3 D4
            
            const codeword = [0, 0, 0, 0, 0, 0, 0]; // Positions 0-6 (index 0 unused)
            
            // Place data bits
            codeword[3] = messageBits[0]; // D1 at position 3
            codeword[5] = messageBits[1]; // D2 at position 5
            codeword[6] = messageBits[2]; // D3 at position 6
            codeword[7] = messageBits[3]; // D4 at position 7
            
            // Calculate parity bits
            codeword[1] = codeword[3] ^ codeword[5] ^ codeword[7]; // P1: positions with bit 1 set
            codeword[2] = codeword[3] ^ codeword[6] ^ codeword[7]; // P2: positions with bit 2 set
            codeword[4] = codeword[5] ^ codeword[6] ^ codeword[7]; // P4: positions with bit 4 set
            
            const codewordStr = codeword.slice(1).join('');
            const parityStr = `P1=${codeword[1]}, P2=${codeword[2]}, P4=${codeword[4]}`;
            
            document.getElementById('origMessage').textContent = messageInput;
            document.getElementById('generatedCodeword').textContent = codewordStr;
            document.getElementById('parityBits').textContent = parityStr;
            
            encodeResult.classList.remove('error');
            encodeResult.classList.add('success');
            encodeResult.style.display = 'block';

            // Auto-populate decode section with this codeword
            document.getElementById('receivedCodeword').value = codewordStr;
        }

        function decodeHamming() {
            const receivedInput = document.getElementById('receivedCodeword').value.trim();
            const decodeResult = document.getElementById('decodeResult');
            const hammingError = document.getElementById('hammingError');

            hammingError.style.display = 'none';
            decodeResult.style.display = 'none';

            if (receivedInput.length !== 7) {
                showError(hammingError, '‚ùå Codeword must be exactly 7 bits');
                return;
            }

            if (!/^[01]{7}$/.test(receivedInput)) {
                showError(hammingError, '‚ùå Codeword must only contain 0s and 1s');
                return;
            }

            const receivedBits = [0, ...receivedInput.split('').map(Number)]; // 1-indexed
            
            // Calculate syndrome
            const s1 = receivedBits[1] ^ receivedBits[3] ^ receivedBits[5] ^ receivedBits[7];
            const s2 = receivedBits[2] ^ receivedBits[3] ^ receivedBits[6] ^ receivedBits[7];
            const s4 = receivedBits[4] ^ receivedBits[5] ^ receivedBits[6] ^ receivedBits[7];
            
            const syndrome = s1 + s2 * 2 + s4 * 4;
            const syndromeStr = `${s1}${s2}${s4} (Decimal: ${syndrome})`;
            
            // Correct error if detected
            const correctedBits = [...receivedBits];
            if (syndrome !== 0) {
                correctedBits[syndrome] ^= 1; // Flip the error bit
            }
            
            const correctedStr = correctedBits.slice(1).join('');
            
            // Extract data bits
            const d1 = correctedBits[3];
            const d2 = correctedBits[5];
            const d3 = correctedBits[6];
            const d4 = correctedBits[7];
            const decodedMessage = `${d1}${d2}${d3}${d4}`;
            const dataBitsStr = `D1=${d1}, D2=${d2}, D3=${d3}, D4=${d4}`;
            
            document.getElementById('receivedValue').textContent = receivedInput;
            document.getElementById('syndromeValue').textContent = syndromeStr;
            
            const errorStatus = document.getElementById('errorStatus');
            if (syndrome === 0) {
                errorStatus.innerHTML = '<div class="result-box success">‚úÖ No errors detected! Codeword is valid.</div>';
            } else {
                errorStatus.innerHTML = `<div class="result-box success">‚úÖ Error detected at position ${syndrome}. Corrected automatically!</div>`;
            }
            
            document.getElementById('correctedCodeword').textContent = correctedStr;
            document.getElementById('decodedMessage').textContent = decodedMessage;
            document.getElementById('dataBits').textContent = dataBitsStr;
            
            decodeResult.classList.remove('error');
            decodeResult.classList.add('success');
            decodeResult.style.display = 'block';
        }

        function randomMessage() {
            const randomMsg = Math.floor(Math.random() * 16).toString(2).padStart(4, '0');
            document.getElementById('messageInput').value = randomMsg;
            encodeHamming();
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        function showError(element, message) {
            element.innerHTML = message;
            element.classList.remove('success');
            element.classList.add('error');
            element.style.display = 'block';
        }

        // ============================================
        // INITIALIZE ON PAGE LOAD
        // ============================================

        window.addEventListener('load', function() {
            // Pre-load example
            loadExample1();
            encodeHamming();
        });
    </script>
</body>
</html>